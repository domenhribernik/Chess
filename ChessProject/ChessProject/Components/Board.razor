@using ChessProject.PiecesData

@for (int i = 0; i < 8; i++)
{
    int localI = i;
    <div class="row">
        @for (int j = 0; j < 8; j++)
        { //tukaj se lahko dodajo ostale figure
            int localJ = j;
            var pawn = blackPawns.FirstOrDefault(n => n.Column == j && n.Row == i);
            var rook = blackRooks.FirstOrDefault(n => n.Column == j && n.Row == i);
            var bishop = blackBishops.FirstOrDefault(n => n.Column == j && n.Row == i);
            var knight = blackKnights.FirstOrDefault(n => n.Column == j && n.Row == i);
            var queen = blackQueen.FirstOrDefault(n => n.Column == j && n.Row == i);
            var king = blackKing.FirstOrDefault(n => n.Column == j && n.Row == i);
            if (pawn == null)
            {
                pawn = whitePawns.FirstOrDefault(n => n.Column == j && n.Row == i);
            }
            if (rook == null)
            {
                rook = whiteRooks.FirstOrDefault(n => n.Column == j && n.Row == i);
            }
            if (bishop == null)
            {
                bishop = whiteBishops.FirstOrDefault(n => n.Column == j && n.Row == i);
            }
            if (knight == null)
            {
                knight = whiteKnights.FirstOrDefault(n => n.Column == j && n.Row == i);
            }
            if (queen == null)
            {
                queen = whiteQueen.FirstOrDefault(n => n.Column == j && n.Row == i);
            }
            if (king == null)
            {
                king = whiteKing.FirstOrDefault(n => n.Column == j && n.Row == i);
            }

            bool canMoveHere = cellsPossible.Contains((i, j));

            <div @onclick="() => MovePiece(localI, localJ)" class="cell @(canMoveHere ? "active" : "")">

                @if (pawn != null)
                {
                    <div @onclick="() => { PieceClicked(pawn); }"
                    class="pawn @pawn.Color @(pawn == activePiece1 ? "active" : "")">

                        @if (pawn.Color == "black")
                        {
                            <img class="board-piece" src="/pictures/black_pawn.svg" />
                        }
                        else
                        {
                            <img class="board-piece" src="/pictures/white_pawn.svg" />
                        }
                    </div>
                }

                @if (rook != null)
                {
                    <div @onclick="() => { PieceClicked(rook); }"
                    class="rook @rook.Color @(rook == activePiece1 ? "active" : "")">

                        @if (rook.Color == "black")
                        {
                            <img class="board-piece" src="/pictures/black_rook.svg" />
                        }
                        else if (rook.Color == "white")
                        {
                            <img class="board-piece" src="/pictures/white_rook.svg" />
                        }
                    </div>
                }

                @if (bishop != null)
                {
                    <div @onclick="() => { PieceClicked(bishop); }"
                    class="bishop @bishop.Color @(bishop == activePiece1 ? "active" : "")">
                        @if (bishop.Color == "black")
                        {
                            <img class="board-piece" src="/pictures/black_bishop.svg" />
                        }
                        else if (bishop.Color == "white")
                        {
                            <img class="board-piece" src="/pictures/white_bishop.svg" />
                        }
                    </div>
                }

                @if (knight != null)
                {
                    <div @onclick="() => { PieceClicked(knight); }"
                    class="knight @knight.Color @(knight == activePiece1 ? "active" : "")">
                        @if (knight.Color == "black")
                        {
                            <img class="board-piece" src="/pictures/black_knight.svg" />
                        }
                        else if (knight.Color == "white")
                        {
                            <img class="board-piece" src="/pictures/white_knight.svg" />
                        }
                    </div>
                }

                @if (queen != null)
                {
                    <div @onclick="() => { PieceClicked(queen); }"
                    class="queen @queen.Color @(queen == activePiece1 ? "active" : "")">
                        @if (queen.Color == "black")
                        {
                            <img class="board-piece" src="/pictures/black_queen.svg" />
                        }
                        else if (queen.Color == "white")
                        {
                            <img class="board-piece" src="/pictures/white_queen.svg" />
                        }
                    </div>
                }

                @if (king != null)
                {
                    <div @onclick="() => { PieceClicked(king); }"
                    class="king @king.Color @(king == activePiece1 ? "active" : "")">
                        @if (king.Color == "black")
                        {
                            <img class="board-piece" src="/pictures/black_king.svg" />
                        }
                        else if (king.Color == "white")
                        {
                            <img class="board-piece" src="/pictures/white_king.svg" />
                        }
                    </div>
                }
            </div>
        }
    </div>
}

@code {
    //list, ki bo imel liste vseh figur
    List<PieceData> piecesList = new List<PieceData>();

    //v teh dveh seznamih so listi figur po barvah
    List<PieceData> whitePieces = new List<PieceData>();
    List<PieceData> blackPieces = new List<PieceData>();

    //kmeti
    List<PieceData> whitePawns = new List<PieceData>();
    List<PieceData> blackPawns = new List<PieceData>();

    //trdnjave
    List<PieceData> whiteRooks = new List<PieceData>();
    List<PieceData> blackRooks = new List<PieceData>();

    //strelci
    List<PieceData> whiteBishops = new List<PieceData>();
    List<PieceData> blackBishops = new List<PieceData>();

    //konji
    List<PieceData> whiteKnights = new List<PieceData>();
    List<PieceData> blackKnights = new List<PieceData>();

    //kraljici
    List<PieceData> whiteQueen = new List<PieceData>();
    List<PieceData> blackQueen = new List<PieceData>();

    //kralja
    List<PieceData> whiteKing = new List<PieceData>();
    List<PieceData> blackKing = new List<PieceData>();

    string black = "black";
    string white = "white";
    bool whiteTurn = true;

    bool blackHasChess = false; //crni je v šahu
    bool whiteHasChess = false;

    //za izpis vrst bi lahko dodav kao ascii znak 55 da bi bla crka in st.

    protected override void OnInitialized()
    {
        //kmeti
        for (int i = 0; i < 8; i++)
        {
            blackPawns.Add(new PieceData
                {
                    Color = "black",
                    Column = i,
                    Row = 1,
                    Direction = Direction.Down,
                    Type = PiecesData.Type.Pawn
                });

            blackPieces.Add(blackPawns[i]);
        }

        for (int i = 0; i < 8; i++)
        {
            whitePawns.Add(new PieceData
                {
                    Color = "white",
                    Column = i,
                    Row = 6,
                    Direction = Direction.Up,
                    Type = PiecesData.Type.Pawn
                });

            whitePieces.Add(whitePawns[i]);
        }

        //trdnjave
        for (int i = 0; i < 8; i += 7)
        {
            blackRooks.Add(new PieceData
                {
                    Color = "black",
                    Column = i,
                    Row = 0,
                    Direction = Direction.Straight,
                    Type = PiecesData.Type.Rook
                });
        }

        for (int i = 0; i < 8; i += 7)
        {
            whiteRooks.Add(new PieceData
                {
                    Color = "white",
                    Column = i,
                    Row = 7,
                    Direction = Direction.Straight,
                    Type = PiecesData.Type.Rook
                });
        }

        //strelci
        for (int i = 1; i < 7; i += 5)
        {
            blackBishops.Add(new PieceData
                {
                    Color = "black",
                    Column = i,
                    Row = 0,
                    Direction = Direction.Diagonally,
                    Type = PiecesData.Type.Bishop
                });
        }

        for (int i = 1; i < 7; i += 5)
        {
            whiteBishops.Add(new PieceData
                {
                    Color = "white",
                    Column = i,
                    Row = 7,
                    Direction = Direction.Diagonally,
                    Type = PiecesData.Type.Bishop
                });
        }

        //konji
        for (int i = 2; i < 6; i += 3)
        {
            blackKnights.Add(new PieceData
                {
                    Color = "black",
                    Column = i,
                    Row = 0,
                    Direction = Direction.LShape,
                    Type = PiecesData.Type.Knight
                });
        }

        for (int i = 2; i < 6; i += 3)
        {
            whiteKnights.Add(new PieceData
                {
                    Color = "white",
                    Column = i,
                    Row = 7,
                    Direction = Direction.LShape,
                    Type = PiecesData.Type.Knight
                });
        }

        for (int i = 0; i < 2; i++)
        {
            blackPieces.Add(blackRooks[i]);
            whitePieces.Add(whiteRooks[i]);

            blackPieces.Add(blackBishops[i]);
            whitePieces.Add(whiteBishops[i]);

            blackPieces.Add(blackKnights[i]);
            whitePieces.Add(whiteKnights[i]);
        }

        //kraljici
        blackQueen.Add(new PieceData
            {
                Color = "black",
                Column = 3,
                Row = 0,
                Direction = Direction.Any,
                Type = PiecesData.Type.Queen
            });

        blackPieces.Add(blackQueen[0]);

        whiteQueen.Add(new PieceData
            {
                Color = "white",
                Column = 3,
                Row = 7,
                Direction = Direction.Any,
                Type = PiecesData.Type.Queen
            });

        whitePieces.Add(whiteQueen[0]);

        //kralja
        blackKing.Add(new PieceData
            {
                Color = "black",
                Column = 4,
                Row = 0,
                Direction = Direction.OneAny,
                Type = PiecesData.Type.King
            });

        blackPieces.Add(blackKing[0]);

        whiteKing.Add(new PieceData
            {
                Color = "white",
                Column = 4,
                Row = 7,
                Direction = Direction.OneAny,
                Type = PiecesData.Type.King
            });

        whitePieces.Add(whiteKing[0]);
    }

    PieceData activePiece1 = null;

    List<(int row, int column)> cellsPossible = new();
    List<(int row, int column)> cellsPossibleCheckChess = new();

    //preveri kam lahko gre
    void CheckDirections(PieceData activePiece)
    {
        cellsPossible.Clear();

        if (activePiece != null)
        {
            //tu noter je treba pazit ali se figura poje in preveri na tak nacin, ali pa se premakne, ker ima prosto polje!!!!

            //crni poje 1 naprej diagonalno le poje
            if ((activePiece.Color == black) && (activePiece.Type == PiecesData.Type.Pawn))
            {
                if (IfFigureExists(activePiece.Row + 1, activePiece.Column - 1))
                {
                    var whitePiece = whitePieces.FirstOrDefault(n => n.Row == activePiece.Row + 1 && n.Column == activePiece.Column - 1);
                    if ((whitePiece != null))//&& !checkIfChessCoordinates(activePiece.Row + 1, activePiece.Column - 1)
                    {
                        cellsPossible.Add((activePiece.Row + 1, activePiece.Column - 1));
                    }
                }
                if (IfFigureExists(activePiece.Row + 1, activePiece.Column + 1))
                {
                    var whitePiece = whitePieces.FirstOrDefault(n => n.Row == activePiece.Row + 1 && n.Column == activePiece.Column + 1);
                    if ((whitePiece != null))//&& !checkIfChessCoordinates(activePiece.Row + 1, activePiece.Column + 1)
                    {
                        cellsPossible.Add((activePiece.Row + 1, activePiece.Column + 1));
                    }
                }
            }

            //beli poje 1 naprej diagonalno
            if ((activePiece.Color == white) && ((activePiece.Type == PiecesData.Type.Pawn) || (activePiece.Type == PiecesData.Type.King)))
            {
                if (IfFigureExists(activePiece.Row - 1, activePiece.Column - 1))
                {
                    var blackPiece = blackPieces.FirstOrDefault(n => n.Row == activePiece.Row - 1 && n.Column == activePiece.Column - 1);
                    if ((blackPiece != null))//&& !checkIfChessCoordinates(activePiece.Row - 1, activePiece.Column - 1)
                    {
                        cellsPossible.Add((activePiece.Row - 1, activePiece.Column - 1));
                    }
                }
                if (IfFigureExists(activePiece.Row - 1, activePiece.Column + 1))
                {
                    var blackPiece = blackPieces.FirstOrDefault(n => n.Row == activePiece.Row - 1 && n.Column == activePiece.Column + 1);
                    if ((blackPiece != null))//&& !checkIfChessCoordinates(activePiece.Row - 1, activePiece.Column + 1)
                    {
                        cellsPossible.Add((activePiece.Row - 1, activePiece.Column + 1));
                    }
                }
            }

            //1 polje naprej premakne
            if ((activePiece.Type == PiecesData.Type.Pawn) || (activePiece.Type == PiecesData.Type.Rook) || (activePiece.Type == PiecesData.Type.Queen))
            {
                if (activePiece.Color == black)
                {
                    AddIfFigureNotExists(activePiece.Row + 1, activePiece.Column);
                }
                else if (activePiece.Color == white)
                {
                    AddIfFigureNotExists(activePiece.Row - 1, activePiece.Column);
                }
            }


            //za 2 polja naprej na zacetku premakne
            if (activePiece.Type == PiecesData.Type.Pawn) 
            {
                if ((activePiece.Row == 1) && (activePiece.Color == black) && (!IfFigureExists(2, activePiece.Column)))
                {
                    AddIfFigureNotExists(3, activePiece.Column);
                }
                else if ((activePiece.Row == 6) && (activePiece.Color == white) && (!IfFigureExists(5, activePiece.Column)))
                {
                    AddIfFigureNotExists(4, activePiece.Column);
                }
            }

            //premik za 1 polje gor, dol, levo, desno, poje ce treba
            if ((activePiece.Type == PiecesData.Type.Rook) || (activePiece.Type == PiecesData.Type.Queen) || (activePiece.Type == PiecesData.Type.King))
            {
                if (activePiece.Type == PiecesData.Type.King)
                {
                    //if ((activePiece.Type == PiecesData.Type.King) && !checkIfChessCoordinates(activePiece.Row, activePiece.Column + 1))
                    //{
                    AddIfSameColorNotExists(activePiece, activePiece.Row, activePiece.Column + 1);
                    //}

                    //if ((activePiece.Type == PiecesData.Type.King) && !checkIfChessCoordinates(activePiece.Row, activePiece.Column - 1))
                    //{
                    AddIfSameColorNotExists(activePiece, activePiece.Row, activePiece.Column - 1);
                    //}

                    //if ((activePiece.Type == PiecesData.Type.King) && !checkIfChessCoordinates(activePiece.Row + 1, activePiece.Column))
                    //{
                    AddIfSameColorNotExists(activePiece, activePiece.Row + 1, activePiece.Column);
                    //}

                    //if ((activePiece.Type == PiecesData.Type.King) && !checkIfChessCoordinates(activePiece.Row - 1, activePiece.Column))

                    //{
                    AddIfSameColorNotExists(activePiece, activePiece.Row - 1, activePiece.Column);
                    //}
                }
                else
                {
                    AddIfSameColorNotExists(activePiece, activePiece.Row, activePiece.Column + 1);
                    AddIfSameColorNotExists(activePiece, activePiece.Row, activePiece.Column - 1);
                    AddIfSameColorNotExists(activePiece, activePiece.Row + 1, activePiece.Column);
                    AddIfSameColorNotExists(activePiece, activePiece.Row - 1, activePiece.Column);
                }
            }

            //diagonalni premik za 1 polje, poje ce treba, ponovi vajo od zgor
            if ((activePiece.Type == PiecesData.Type.Bishop) || (activePiece.Type == PiecesData.Type.Queen) || (activePiece.Type == PiecesData.Type.King))
            {
                AddIfSameColorNotExists(activePiece, activePiece.Row + 1, activePiece.Column + 1);
                AddIfSameColorNotExists(activePiece, activePiece.Row + 1, activePiece.Column - 1);
                AddIfSameColorNotExists(activePiece, activePiece.Row - 1, activePiece.Column + 1);
                AddIfSameColorNotExists(activePiece, activePiece.Row - 1, activePiece.Column - 1);
            }
        }
    }

    bool checkIfChess()
    {
        blackHasChess = false;
        whiteHasChess = false;

        //ce ima crni sah
        for (int i = 0; i < whitePieces.Count; i++)
        {
            if (blackHasChess)
            {
                break;
            }

            PieceData activeHolder;
            activeHolder = whitePieces[i];
            if (!(activeHolder.Type == PiecesData.Type.King))
            {
                CheckDirections(activeHolder);
                for (int j = 0; j < cellsPossible.Count; j++)
                {
                    if ((cellsPossible[j].row == blackKing[0].Row) && (cellsPossible[j].column == blackKing[0].Column))
                    {
                        blackHasChess = true;
                        Console.WriteLine("Crni mas sah!");
                        break;
                    }
                }
            }
            //CheckDirections(activePiece1);
        }

        //ce ima beli sah
        for (int i = 0; i < blackPieces.Count; i++)
        {
            if (whiteHasChess)
            {
                break;
            }

            PieceData activeHolder;
            activeHolder = blackPieces[i];
            if (!(activeHolder.Type == PiecesData.Type.King))
            {
                CheckDirections(activeHolder);
                for (int j = 0; j < cellsPossible.Count; j++)
                {
                    if ((cellsPossible[j].row == whiteKing[0].Row) && (cellsPossible[j].column == whiteKing[0].Column))
                    {
                        whiteHasChess = true;
                        Console.WriteLine("Beli mas sah!");
                        break;
                    }
                }
            }
            //CheckDirections(activePiece1);
        }

        if ((whiteTurn && whiteHasChess) || (!whiteTurn && blackHasChess))
        {
            return true;
        }
        else
        {
            return false;
        }
    }

    bool checkIfChessCoordinates(int row, int column)
    {
        blackHasChess = false;
        whiteHasChess = false;

        //ce ima crni sah
        if (!whiteTurn)
        {
            if (activePiece1.Type == PiecesData.Type.King)
            {
                for (int i = 0; i < whitePieces.Count; i++)
                {
                    if (blackHasChess)
                    {
                        break;
                    }

                    PieceData activeHolder;
                    activeHolder = whitePieces[i];
                    if (!(activeHolder.Type == PiecesData.Type.King))
                    {
                        CheckDirections(activeHolder);
                        for (int j = 0; j < cellsPossible.Count; j++)
                        {
                            if ((cellsPossible[j].row == row) && (cellsPossible[j].column == column))
                            {
                                blackHasChess = true;
                                Console.WriteLine("Crni mas sah!");
                                break;
                            }
                        }
                    }
                    //CheckDirections(activePiece1);
                }
            }
            else 
            {
                int rowHolder = activePiece1.Row;
                int columnHolder = activePiece1.Column;
                activePiece1.Row = row;
                activePiece1.Column = column;
                if (checkIfChess())
                {
                    activePiece1.Row = rowHolder;
                    activePiece1.Column = columnHolder;
                    return true;
                }

                activePiece1.Row = rowHolder;
                activePiece1.Column = columnHolder;
                return false;
            }

        }

        if (whiteTurn)
        {
            //ce ima beli sah
            if (activePiece1.Type == PiecesData.Type.King)
            {
                foreach (var i in blackPieces)
                {
                    if (whiteHasChess)
                    {
                        break;
                    }

                    PieceData activeHolder;
                    activeHolder = i;
                    if (!(activeHolder.Type == PiecesData.Type.King))
                    {
                        CheckDirections(activeHolder);
                        foreach (var j in cellsPossible)
                        {
                            if ((j.row == row) && (j.column == column))
                            {
                                whiteHasChess = true;
                                Console.WriteLine("Beli mas sah!");
                                break;
                            }
                        }
                    }
                    //CheckDirections(activePiece1);
                }
            }
            else
            {
                int rowHolder = activePiece1.Row;
                int columnHolder = activePiece1.Column;
                activePiece1.Row = row;
                activePiece1.Column = column;
                //Console.WriteLine("TT1: " + activePiece1.Row + " : " + activePiece1.Column);
                if (checkIfChess())
                {
                    activePiece1.Row = rowHolder;
                    activePiece1.Column = columnHolder;
                    //Console.WriteLine("True1: " + activePiece1.Row + " : " + activePiece1.Column);
                    return true;
                }

                //Console.WriteLine("RH+CH = " + rowHolder + " : " + columnHolder);
                activePiece1.Row = rowHolder;
                activePiece1.Column = columnHolder;
                //Console.WriteLine("RH+CH = " + rowHolder + " : " + columnHolder);
                //Console.WriteLine("False1: " + activePiece1.Row + " : " + activePiece1.Column);
                return false;
            }
        }

        if ((whiteTurn && whiteHasChess) || (!whiteTurn && blackHasChess))
        {
            return true;
        }
        else
        {
            return false;
        }
    }

    void removeNotPossibleCells()
    {
        List<(int row, int column)> cellsToRemove = new();
        List<(int row, int column)> celPosHolder = new();
        //CheckDirections(activePiece1);
        //Console.WriteLine(activePiece1.Type + "  : " + activePiece1.Color);
        celPosHolder = cellsPossible.ToList();
        int cellCount = cellsPossible.Count;
        foreach (var f in celPosHolder.ToList())
        {
            //Console.WriteLine("L1: " + activePiece1.Type + "  : " + activePiece1.Color);
            //Console.WriteLine("PL1: " +f.row  +" : "+ f.column);
            //Console.WriteLine("size: " + celPosHolder.Count + "  ; index: " + f);
            /*if (activePiece1.Type == PiecesData.Type.King)
            {

            }*/
            if (checkIfChessCoordinates(f.row, f.column))
            {
                //Console.WriteLine("F1: " + f.row + "  : " + f.column);
                //Console.WriteLine("size: " + celPosHolder.Count + "  ; index: " + f);
                //Console.WriteLine("Problem: " + tmpList[f].row + " : " + tmpList[f].column);
                cellsToRemove.Add(f);//(celPosHolder[f].row, celPosHolder[f].column)
            }
        }



        CheckDirections(activePiece1);
        /*
        foreach (var c in cellsToRemove)
        {
            Console.WriteLine("C2R: " + c);
        }
        foreach (var c in cellsPossible)
        {
            Console.WriteLine("Pos: " + c);
        }*/

        foreach (var i in cellsPossible.ToList())
        {
            foreach (var j in cellsToRemove.ToList())
            {
                //Console.WriteLine("IF: " + i + " == " + j);
                if (i == j)
                {
                    //Console.WriteLine("REMOVE IT!!!");
                    cellsPossible.Remove(j);
                    break;
                }
            }
        }

    }

    bool IfFigureExists(int row, int column)
    {
        var blackPiece = blackPieces.FirstOrDefault(n => n.Column == column && n.Row == row);
        var whitePiece = whitePieces.FirstOrDefault(n => n.Column == column && n.Row == row);

        if ((blackPiece == null) && (whitePiece == null))
        {
            return false;
        }
        else
        {
            return true;
        }
    }

    bool IfWhiteFigureExists(int row, int column)
    {
        var blackPiece = blackPieces.FirstOrDefault(n => n.Column == column && n.Row == row);
        var whitePiece = whitePieces.FirstOrDefault(n => n.Column == column && n.Row == row);

        if ((blackPiece == null) && (whitePiece != null))
        {
            return true;
        }
        else
        {
            return false;
        }
    }

    bool IfBlackFigureExists(int row, int column)
    {
        var blackPiece = blackPieces.FirstOrDefault(n => n.Column == column && n.Row == row);
        var whitePiece = whitePieces .FirstOrDefault(n => n.Column == column && n.Row == row);

        if ((blackPiece != null) && (whitePiece == null))
        {
            return true;
        }
        else
        {
            return false;
        }
    }

    void AddIfFigureNotExists(int row, int column)
    {
        if (!IfFigureExists(row, column))//&& !checkIfChessCoordinates(row, column)
        {
            cellsPossible.Add((row, column));
        }
    }

    void AddIfSameColorNotExists(PieceData activePiece, int row, int column) 
    {
        if ((activePiece.Color == white) && !IfWhiteFigureExists(row, column))//&& !checkIfChessCoordinates(row, column)
        {
            cellsPossible.Add((row, column));
        }
        else if ((activePiece.Color == black) && !IfBlackFigureExists(row, column))//&& !checkIfChessCoordinates(row, column)
        {
            cellsPossible.Add((row, column));
        }
    }

    //premika
    void MovePiece(int row, int column)
    {
        /*
        for (int i = 0; i < cellsPossible.Count; i++)
        {
            Console.WriteLine("cell " + i + "  size: " + cellsPossible.Count + "  ;  " + cellsPossible[i].row + "  :  " + cellsPossible[i].column);
        }
        removeNotPossibleCells();
        for (int i = 0; i < cellsPossible.Count; i++)
        {
            Console.WriteLine("11cell " + i + "  size: " + cellsPossible.Count + "  ;  " + cellsPossible[i].row + "  :  " + cellsPossible[i].column);
        }*/
        bool canMoveHere = cellsPossible.Contains((row, column));
        if (!canMoveHere)
        {
            //Console.WriteLine("Ne more: " + row + " : " + column);
            return;
        }
        //Console.WriteLine("Lahko");
        //katero figuro je treba pojest
        if (IfWhiteFigureExists(row, column) && !whiteTurn)
        {
            var whitePiece = whitePieces.FirstOrDefault(n => n.Row == row && n.Column == column);
            if (whitePiece != null)
            {
                switch(whitePiece.Type)
                {
                    case PiecesData.Type.Pawn:
                        whitePawns.Remove(whitePiece);
                        break;
                    case PiecesData.Type.Rook:
                        whiteRooks.Remove(whitePiece);
                        break;
                    case PiecesData.Type.Bishop:
                        whiteBishops.Remove(whitePiece);
                        break;
                    case PiecesData.Type.Knight:
                        whiteKnights.Remove(whitePiece);
                        break;
                    case PiecesData.Type.Queen:
                        whiteQueen.Remove(whitePiece);
                        break;
                    //za zdaj lahko kralja pojes
                    case PiecesData.Type.King:
                        whiteKing.Remove(whitePiece);
                        break;
                }
                whitePieces.Remove(whitePiece);
            }
        }
        else if (IfBlackFigureExists(row, column) && whiteTurn)
        {
            var blackPiece = blackPieces.FirstOrDefault(n => n.Row == row && n.Column == column);

            if (blackPiece != null)
            {
                switch (blackPiece.Type)
                {
                    case PiecesData.Type.Pawn:
                        blackPawns.Remove(blackPiece);
                        break;
                    case PiecesData.Type.Rook:
                        blackRooks.Remove(blackPiece);
                        break;
                    case PiecesData.Type.Bishop:
                        blackBishops.Remove(blackPiece);
                        break;
                    case PiecesData.Type.Knight:
                        blackKnights.Remove(blackPiece);
                        break;
                    case PiecesData.Type.Queen:
                        blackQueen.Remove(blackPiece);
                        break;
                    //za zdaj lahko kralja pojes
                    case PiecesData.Type.King:
                        blackKing.Remove(blackPiece);
                        break;
                }
                blackPieces.Remove(blackPiece);
            }
        }

        //premik
        activePiece1.Column = column;
        activePiece1.Row = row;

        activePiece1 = null;
        whiteTurn = !whiteTurn;
        checkIfChess();
        CheckDirections(activePiece1);
    }

    void PieceClicked(PieceData piece)
    {
        if (whiteTurn && piece.Color == black)
        {
            return;
        }
        if (!whiteTurn && piece.Color == white)
        {
            return;
        }

        if (activePiece1 == piece)
        {
            activePiece1 = null;
        }
        else
        {
            activePiece1 = piece;
        }

        CheckDirections(activePiece1);
    }
}