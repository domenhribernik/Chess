@using ChessProject.PiecesData

@for (int i = 0; i < 8; i++) {
    int localI = i;
    <div class="row">
    @for (int j = 0; j < 8; j++) {
            int localJ = j;
            var pawn = blackPawns.FirstOrDefault(n => n.Column == j && n.Row == i);
            if (pawn == null) {
                pawn = whitePawns.FirstOrDefault(n => n.Column == j && n.Row == i);
            }

            bool canMoveHere = cellsPossible.Contains((i, j));

            <div @onclick="() => MovePawn(localI, localJ)" class="cell @(canMoveHere ? "active" : "")">
                @if (pawn != null) {
                    <div @onclick="() => { PawnClicked(pawn); }"
                        class="pawn @pawn.Color @(pawn == activePawn ? "active" : "")">

                        @if (pawn.Color == "black") {
                            <img class="board-piece" src="/pictures/black_pawn.svg" />
                        }
                        else {
                            <img class="board-piece" src="/pictures/white_pawn.svg" />
                        }
                    </div>
                }
            </div>
    }
    </div>
}

@code {
    List<PawnData> whitePawns = new List<PawnData>();
    List<PawnData> blackPawns = new List<PawnData>();
    string black = "black";
    string white = "white";
    bool whiteTurn = true;

    protected override void OnInitialized()
    {
        for (int i = 0; i < 8; i++)
        {
            blackPawns.Add(new PawnData
            {
                Color = "black",
                Column = i,
                Row = 1,
                Direction = PawnDirection.Down
                });
        }

        for (int i = 0; i < 8; i++)
        {
            whitePawns.Add(new PawnData
            {
                Color = "white",
                Column = i,
                Row = 6,
                Direction = PawnDirection.Up
            });
        }
    }

    PawnData activePawn = null;


    List<(int row, int column)> cellsPossible = new();

    //preveri kam lahko gre
    void CheckDirectionsPawns() {
        cellsPossible.Clear();

        if (activePawn != null)
        {
            //crni kmet poje
            if ((activePawn.Color == black) && (IfFigureExists(activePawn.Row + 1, activePawn.Column - 1)))
            {
                var whitePawn = whitePawns.FirstOrDefault(n => n.Row == activePawn.Row + 1 && n.Column == activePawn.Column - 1);
                if (whitePawn != null)
                {
                    cellsPossible.Add((activePawn.Row + 1, activePawn.Column - 1));
                }
            }
            if ((activePawn.Color == black) && (IfFigureExists(activePawn.Row + 1, activePawn.Column + 1)))
            {
                var whitePawn = whitePawns.FirstOrDefault(n => n.Row == activePawn.Row + 1 && n.Column == activePawn.Column + 1);
                if (whitePawn != null)
                {
                    cellsPossible.Add((activePawn.Row + 1, activePawn.Column + 1));
                }
            }

            //beli kmet poje
            if ((activePawn.Color == white) && (IfFigureExists(activePawn.Row - 1, activePawn.Column - 1)))
            {
                var blackPawn = blackPawns.FirstOrDefault(n => n.Row == activePawn.Row - 1 && n.Column == activePawn.Column - 1);
                if (blackPawn != null)
                {
                    cellsPossible.Add((activePawn.Row - 1, activePawn.Column - 1));
                }
            }
            if ((activePawn.Color == white) && (IfFigureExists(activePawn.Row - 1, activePawn.Column + 1)))
            {
                var blackPawn = blackPawns.FirstOrDefault(n => n.Row == activePawn.Row - 1 && n.Column == activePawn.Column + 1);
                if (blackPawn != null)
                {
                    cellsPossible.Add((activePawn.Row - 1, activePawn.Column + 1));
                }
            }

            //1 polje naprej
            if (activePawn.Direction == PawnDirection.Down) {
                AddIfFigureNotExists(activePawn.Row + 1, activePawn.Column);
            }
            else if (activePawn.Direction == PawnDirection.Up)
            {
                AddIfFigureNotExists(activePawn.Row - 1, activePawn.Column);
            }

            //za 2 naprej na zacetku
            if ((activePawn.Row == 1) && (activePawn.Color == black) && (!IfFigureExists(2, activePawn.Column)))
            {
                AddIfFigureNotExists(3, activePawn.Column);
            }
            else if ((activePawn.Row == 6) && (activePawn.Color == white) && (!IfFigureExists(5, activePawn.Column)))
            {
                AddIfFigureNotExists(4, activePawn.Column);
            }
        }
    }

    bool IfFigureExists(int row, int column)
    {
        var blackPawn = blackPawns.FirstOrDefault(n => n.Column == column && n.Row == row);
        var whitePawn = whitePawns.FirstOrDefault(n => n.Column == column && n.Row == row);

        if ((blackPawn == null) && (whitePawn == null))
        {
            return false;
        }
        else {
            return true;
        }
    }

    bool IfWhiteFigureExists(int row, int column) {
        var blackPawn = blackPawns.FirstOrDefault(n => n.Column == column && n.Row == row);
        var whitePawn = whitePawns.FirstOrDefault(n => n.Column == column && n.Row == row);

        if ((blackPawn == null) && (whitePawn != null))
        {
            return true;
        }
        else
        {
            return false;
        }
    }

    bool IfBlackFigureExists(int row, int column)
    {
        var blackPawn = blackPawns.FirstOrDefault(n => n.Column == column && n.Row == row);
        var whitePawn = whitePawns.FirstOrDefault(n => n.Column == column && n.Row == row);

        if ((blackPawn != null) && (whitePawn == null))
        {
            return true;
        }
        else
        {
            return false;
        }
    }

    void AddIfFigureNotExists(int row, int column) {

        if (!IfFigureExists(row, column)) {
            cellsPossible.Add((row, column));
            //Console.Write(row);
            //Console.Write(column);
            //Console.Write("\n");
        }
    }

    //premika
    void MovePawn(int row, int column) {
        bool canMoveHere = cellsPossible.Contains((row, column));
        if (!canMoveHere) {
            return;
        }

        //katero figuro je treba pojest
        if (IfWhiteFigureExists(row, column) && !whiteTurn) {
            var whitePawn = whitePawns.FirstOrDefault(n => n.Row == row && n.Column == column);
            if (whitePawn != null)
            {
                whitePawns.Remove(whitePawn);
            }
        }
        else if (IfBlackFigureExists(row, column) && whiteTurn)
        {
            var blackPawn = blackPawns.FirstOrDefault(n => n.Row == row && n.Column == column);
            blackPawns.Remove(blackPawn);
        }
        
        //premik
        activePawn.Column = column;
        activePawn.Row = row;

        activePawn = null;
        whiteTurn = !whiteTurn;
        CheckDirectionsPawns();
    }

    void PawnClicked(PawnData pawn) {
        if (whiteTurn && pawn.Color == black) {
            return;
        }
        if (!whiteTurn && pawn.Color == white) {
            return;
        }

        if (activePawn == pawn)
        {
            activePawn = null;
        }
        else
        {
            activePawn = pawn;
        }

        CheckDirectionsPawns();
    }
}